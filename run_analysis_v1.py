import os
import json
import concurrent.futures
import time
import datetime
from mobsf_api import Mobsf


class Instance:
    """Class that represents a Mobsf instance.
    I just created to add an attribute to the Mobsf object, 
    so that I can check if it is available or not.
    I could have added the attribute to the Mobsf class, 
    but I didn't want to change with the mobsf_api's code.
    This class is used only for parallel analysis"""

    def __init__(self, name, mobsf, available=True):
        self.name = name
        self.mobsf = mobsf
        self.available = available
    
    def __str__(self):
        return f"{self.name} - {self.mobsf} - {self.available}"
    
    def __repr__(self):
        return f"{self.name} - {self.mobsf} - {self.available}"




def analyze_file(instance, file_path, destination_directory):
    """Performs static and dynamic analysis on the file with the given path.
    The file is uploaded to mobsf server and then the analysis is performed.
    The file is then moved to the destination directory.
    :param instance: Instance object
    :param file_path: path of the file to be analyzed
    :param destination_directory: directory to move the file after analysis
    is completed"""


    try:
        resp = instance.mobsf.upload_file(file_path)
        if resp is not None:
            file_hash = json.loads(resp)["hash"]
            my_hash = Mobsf.hash_it(file_path, "sha256")
            current_time = datetime.datetime.now().strftime("%H:%M:%S")
            print(f"{current_time} - Hash {file_hash} is being analyzed at {instance.mobsf} ")
            instance.mobsf.scan(file_hash)
            instance.mobsf.scorecard(file_hash, my_hash)
            instance.mobsf.generate_static_json_report(file_hash, my_hash)
            current_time = datetime.datetime.now().strftime("%H:%M:%S")
            print(f"{current_time} - Static report generated for hash: {my_hash}")
            
            """dynamic_status_code = instance.mobsf.start_dynamic_analysis(file_hash)
            if dynamic_status_code != 200:
                raise ValueError(f"Dynamic analysis failed with status code {dynamic_status_code}")
            else:
                instance.mobsf.start_frida_instrumentation(file_hash)
                print("Waiting for instrumentation to finish...")
                time.sleep(10)  # Time until instrumentation finishes
                instance.mobsf.start_activities(file_hash)
                instance.mobsf.get_dependencies(file_hash)
                instance.mobsf.stop_dynamic_analysis(file_hash)
                instance.mobsf.generate_dynamic_json_report(file_hash, my_hash)
                current_time = datetime.datetime.now().strftime("%H:%M:%S")
                print(f"{current_time} - Dynamic report generated for hash: {my_hash}")"""
            
    except ValueError as e:
        print(f"Error during dynamic analysis: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
    finally:
        file_name = os.path.basename(file_path)
        destination_path = os.path.join(destination_directory, file_name)
        if os.path.exists(destination_path):
            os.remove(destination_path)
        os.rename(file_path, destination_path)
        print(f"File moved to: {destination_path}")
    return instance



def parallel_analysis(instances, directory, destination_directory):
    """Performs parallel analysis on the files in the given directory.
    It uses concurrent.futures.ThreadPoolExecutor to run the analysis
    through multiple threads. Each thread is assigned to an instance.
    The instance attribute of each thread is marked as busy while the
    analysis is running and is marked as available when the analysis is
    completed. If all instances are busy, the thread waits for 20 seconds
    so it uses less resources.

    :param instances: list of Instance objects
    :param directory: directory with the files to be analyzed
    :param destination_directory: directory to move the files after analysis
    is completed"""
    with concurrent.futures.ThreadPoolExecutor(max_workers=len(instances)) as executor:
        if os.path.isdir(directory) and os.path.isdir(destination_directory):
            files = [file for file in os.listdir(directory) if file.endswith(".apk")]

            for filename in files:
                available_instance = next((inst for inst in instances if inst.available), None)
                # If all instances are busy, wait and try again
                while available_instance is None:  
                    time.sleep(20)  
                    available_instance = next((inst for inst in instances if inst.available), None)
                # Mark the instance as busy
                available_instance.available = False
                  
                file_path = os.path.join(directory, filename)
                # run file analysis
                future = executor.submit(analyze_file, available_instance, file_path, destination_directory) 
                # Mark the instance as available when the analysis is done
                future.add_done_callback(create_callback(available_instance)) 
                """The add_done_callback method expects a callable that takes a single argument, the Future instance. 
                If I would try to use a lambda function that doesn't take any arguments or takes more than one argument, 
                I'd encounter an error."""
        else:
            print("One or both directories don't exist.")


def create_callback(instance):
    """Creates a callback function for the given instance.
    The callback function marks the instance as available when the
    analysis is completed. It is used because I can't use lambda
    inside the add_done_callback function.
    :param instance: Instance object
    :return: function"""
    # Mark the instance as available when the analysis is done
    return lambda _: setattr(instance, 'available', True) 



"""In the line available_instance = next((inst for inst in instances if inst.available), None), you're assigning a new value to 
available_instance in each iteration of the loop. This is similar to how a loop variable is updated in each iteration of a for loop.

The key point is that when you create a lambda function inside a loop and the function uses a variable that is updated in each 
iteration of the loop, the function captures the variable itself, not its current value. This is why you're seeing the 
AttributeError: 'NoneType' object has no attribute 'available' error. The available_instance is None at the end of your loop, 
so when the callback is executed, it's trying to access the available attribute on None, which doesn't exist.

The solution is to use a function to create the callback, as shown in the second approach. This function creates a new scope 
for each callback, so the instance variable in this new scope is not updated by the loop and retains the correct value when 
the callback is executed."""




