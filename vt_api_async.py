import hashlib
import os
import json
import aiohttp
import asyncio
from time import sleep






API_KEY =   "" #initialize the api key with the api key provided by virustotal
directory_path = "" # path to the directory containing the apk files
base_directory = "" # path to the directory where the subfolders will be created and inside them reports will be saved

HEADERS = {"x-apikey": API_KEY}

def error_handle(response):
    '''
    The function returns True if there are no errors
    and returns False otherwise

    :param response_data: dict
    :return: bool
    '''
    status_code = response.status
    if status_code == 429:
        print(f"Response code {status_code}. Quota exceeded.")
        sleep(60)
    if status_code == 401:
        raise Exception("Invalid API key")
    elif status_code not in (200, 404, 429):
        raise Exception(f"Unexpected status code: {status_code}")
    else:
        return True
    return False


# 404 = upload file
# 400 = wait for resource to be available
# 401 = check user account
# 409 = resource already exists
# 429 = quota exceeded; wait 60 sec
# 200 = OK


def hash_it(file, algorithm):
    '''
    Returns hash of the file provided

    :param file: file to hash (type: str/pathlib obj) :param algorithm: algorithm to
    to use for hashing (valid algorithms: sha1 | sha256 | md5) (type: str)
    :return: file hash (type: str)
    '''
    if algorithm == "sha256":
        hasher = hashlib.sha256()
    elif algorithm == "sha1":
        hasher = hashlib.sha1()
    elif algorithm == "md5":
        hasher = hashlib.md5()
    else:
        raise Exception(
            "Incompatible hash algorithm used. Choose from: sha256 | sha1 | md5")

    with open(file, 'rb') as f:
        hasher.update(f.read())
    return hasher.hexdigest()



async def get_data(file_hash, kind_of_report):
    '''
    The function gets the data against the file hash provided
    from the virustotal api depending on the kind of report we want

    :param f_hash: sha256 of the file to scan with virustotal
    :param kind_of_report: type of report to get(static, dynamic, mitre)
    :return: tuple(status_code, response_text)
    (using status_code to check if the request was successful later on)
    '''
    print("Getting data...")
    if kind_of_report == "static":
        print("static")
        url = f"https://www.virustotal.com/api/v3/files/{file_hash}"
    elif kind_of_report == "dynamic":
        print("dynamic")
        url =  f"https://www.virustotal.com/api/v3/files/{file_hash}/behaviours"
    elif kind_of_report == "mitre_attacks":
        print("mitre_attacks")
        url =  f"https://www.virustotal.com/api/v3/files/{file_hash}/behaviour_mitre_trees"
    else:
        raise Exception("Invalid report type. Choose from static | dynamic | mitre_attacks")
    response_text = None
    response_status = None
    while True:
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, headers=HEADERS) as response:
                    print(f"Status code: {response.status}")
                    if error_handle(response):
                        response_status = response.status
                        response_text = await response.text()
                        break
        except aiohttp.ClientError as e:
            print(f"A network error occurred: {e}")
        except json.JSONDecodeError as e:
            print(f"A JSON decode error occurred: {e}")
        except Exception as e:
            print(f"An error occurred at 'get_data' for {file_hash}: {e}")
        await asyncio.sleep(5)  # sleep for a while before retrying
    return response_status, response_text



async def vt_post_files(file_path, url="https://www.virustotal.com/api/v3/files"):
    """
    Uploads a file to the virustotal api

    :param file_path: path of the file to upload	
    :param url: url to upload the file to (default: https://www.virustotal.com/api/v3/files)
    :return: response_json
    """
    async with aiohttp.ClientSession() as session:
        with open(file_path, "rb") as f:
            file_bin = f.read()
        print("UPLOADING")
        file_name = os.path.basename(file_path)
        data = aiohttp.FormData()
        data.add_field('file', file_bin, filename=file_name)
        while True:
            try:
                async with session.post(url, headers=HEADERS, data=data) as response:
                    print(await response.text())
                    if error_handle(response):
                        response_text = await response.text()
                        response_json = json.loads(response_text)
                        break
            except aiohttp.ClientError as e:
                print(f"A network error occurred: {e}")
            except json.JSONDecodeError as e:
                print(f"A JSON decode error occurred: {e}")
            except Exception as e:
                print(f"An error occurred at 'post_files' for {file_name}: {e}")
            await asyncio.sleep(5)  # sleep for a while before retrying  
        return response_json


async def vt_get_analysis(response):
    """
    Performs the analysis of the file uploaded to the virustotal api
    and waits for it to be completed
    :param response: response of the post_files request
    :return: file_hash
    """
    _id = response.get("data").get("id")
    url = f"https://www.virustotal.com/api/v3/analyses/{_id}"
    print(f"ID: {_id}")
    response_json = {}  # Define response_json with a default value
    file_hash = None  # Define file_hash with a default value
    async with aiohttp.ClientSession() as session:
        print("WAITING FOR ANALYSIS REPORT")
        await asyncio.sleep(60)  
        while True:
            try:
                async with session.get(url, headers=HEADERS) as response:
                    print(await response.text())
                    if error_handle(response):
                        response_text = await response.text()
                        response_json = json.loads(response_text)
                        if response_json.get("data").get("attributes").get("status") == "queued":
                            print("Analysis queued. Waiting for 10 seconds...")
                            await asyncio.sleep(10)
                        elif response_json.get("data").get("attributes").get("status") == "completed":
                            file_hash = response_json.get("meta").get("file_info").get("sha256")
                            break
            except aiohttp.ClientError as e:
                print(f"A network error occurred: {e}")
            except json.JSONDecodeError as e:
                print(f"A JSON decode error occurred: {e}")
            except Exception as e:
                print(f"An error occurred at 'get_analysis' for {_id}: {e}")
            await asyncio.sleep(5)  # sleep for a while before retrying (maybe don't need this) 
        return file_hash  
            

async def get_upload_url():
    '''
    The function returns a url to upload files larger than 32MB
    to the virustotal api
    '''
    url = "https://www.virustotal.com/api/v3/files/upload_url"
    response_json = None
    while True:
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, headers=HEADERS) as response:
                    response_data = await response.text()
                    if error_handle(response_data):
                        response_json = json.loads(response_data)
                        print(response_json)
                        break
        except aiohttp.ClientError as e:
            print(f"A network error occurred: {e}")
        except json.JSONDecodeError as e:
            print(f"A JSON decode error occurred: {e}")
        except Exception as e:
            print(f"An error occurred at get upload_url: {e}")
        await asyncio.sleep(2)
    return response_json



def check_folder_for_existing_report(file_hash, directory ,kind_of_report):
    """
    Checks if a report for the file exists in the directory provided
    in the kind_of_report subfolder

    :param file_hash: hash of the file to check for
    :param directory: directory to check for the report
    :param kind_of_report: type of report to check(dynamic, static, mitre_attacks)
    """
    if kind_of_report == "dynamic":
        sub_folder = os.path.join(directory, "Malware Analysis", f"vt_{kind_of_report}_reports")
    elif kind_of_report == "static":
        sub_folder = os.path.join(directory, "Malware Analysis", f"vt_{kind_of_report}_reports")
    elif kind_of_report == "mitre_attacks":
        sub_folder = os.path.join(directory, "Malware Analysis", f"vt_{kind_of_report}_reports")
    else:
        raise Exception("Invalid report type")
    file_name = f"{kind_of_report}_report_{file_hash}.json"
    file_path = os.path.join(sub_folder, file_name)
    return os.path.exists(file_path)


def save_report(directory, json_report, filename, file_hash, kind_of_report):
    """
    Saves the json report to the directory specified
    by the kind_of_report parameter(dynamic, static, mitre_attacks)
    
    :param directory: directory to where subfolders will be created(if not exist) 
        to save the report
    :param json_report: json report to save
    :param filename: filename of the apk file
    :param hash: hash of the apk file
    :param kind_of_report: type of report to save(dynamic, static, mitre_attacks)
    """
    print("SAVING REPORT")
    if os.path.isdir(directory):
        if kind_of_report == "dynamic":
            sub_folder = os.path.join(directory, "Malware Analysis", f"vt_{kind_of_report}_reports")
        elif kind_of_report == "static":
            sub_folder = os.path.join(directory, "Malware Analysis", f"vt_{kind_of_report}_reports")
        elif kind_of_report == "mitre_attacks":
            sub_folder = os.path.join(directory, "Malware Analysis", f"vt_{kind_of_report}_reports")
        else:
            raise Exception("Invalid report type")
        os.makedirs(sub_folder, exist_ok=True)
        report_path = f"{sub_folder}/{kind_of_report}_report_{file_hash}.json"
        with open(report_path, 'w') as json_file:
            json.dump(json_report, json_file, indent=4)
            print(f"{kind_of_report} report created for {filename}")
    else:
        raise Exception("Directory does not exist")
    



async def main(directory_path, destination_path, kind_of_report):
    """Main function to run the program
    :param directory_path: path to the directory containing the apk files
    :param destination_path: path to the directory where the subfolder of the 
        reports will be created and the reports will be saved
    :param kind_of_report: type of report to save(dynamic, static, mitre_attacks)
    """
    if os.path.isdir(directory_path) and os.path.isdir(destination_path):
        apk_files = [file for file in os.listdir(directory_path) if file.endswith(".apk")]
        sem = asyncio.Semaphore(20)  # limit the number of concurrent tasks
        tasks = [perform_file_analysis(
            sem, os.path.join(directory_path, filename), destination_path, kind_of_report) for filename in apk_files]
        await asyncio.gather(*tasks)
    else:
        raise Exception("One or both directories do not exist")

   

async def perform_file_analysis(sem, file_path, directory, kind_of_report):
    """Gets the hash of the file and checks if there is an existing report.
    If there is no existing report, it checks if the file exists on VT.
    If it exists, it saves the report. If it does not exist, it uploads the file
    and then saves the report.
    :param sem: semaphore to limit the number of concurrent uploads
    :param file_path: path of the file to upload
    :param destination_path: path to save the report
    :param parent_directory: parent directory to save the report
    :param kind_of_report: type of report to save(dynamic, static, mitre_attacks)
    """
    async with sem:  # limit the number of concurrent uploads
        hash_value = hash_it(file_path, "sha256")
        if check_folder_for_existing_report(hash_value, directory , kind_of_report):
            print(f"{kind_of_report}_report for {os.path.basename(file_path)} already exists")
        else:
            print(f"No existing report for {os.path.basename(file_path)}")
            resp_code, resp_data = await get_data(hash_value, kind_of_report)
            response_json = json.loads(resp_data)
            
            if resp_code == 404:
                print(f"File {os.path.basename(file_path)} not found on VT.")
                if os.path.getsize(file_path) > 32000000:
                    print(f"File has size {os.path.getsize(file_path)} KB. Getting upload url...")
                    # for files larger than 32MB
                    resp_code, resp_text = await get_data(await vt_get_analysis(await vt_post_files(
                        file_path, await get_upload_url)), kind_of_report)
                    json_report = json.loads(resp_text)
                    save_report(directory, json_report, os.path.basename(file_path), hash_value, kind_of_report)
                else:
                    # for small files
                    print(f"File has size {os.path.getsize(file_path)} KB. Uploading file...")
                    resp_code, resp_text = await get_data(await vt_get_analysis(
                        await(vt_post_files(file_path))), kind_of_report)
                    json_report = json.loads(resp_text)
                    save_report(directory, json_report, os.path.basename(file_path), hash_value, kind_of_report)
                    
            elif resp_code == 200:
                print("Successful request!")
                save_report(directory, response_json, os.path.basename(file_path), hash_value, kind_of_report)
            else:
                raise Exception(f"Unexpected error at 'perform_analysis'. Status code: {resp_code}")

                

#the third argument is the type of report to save(dynamic, static, mitre_attacks)
if __name__ == "__main__":
    asyncio.run(main(directory_path, base_directory, "dynamic"))

























