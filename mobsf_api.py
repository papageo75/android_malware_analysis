import json
import requests
from requests_toolbelt.multipart.encoder import MultipartEncoder
import os
import datetime
import time
import hashlib


#Before using, initialize all 'directory' variables inside methods with the directory where you want the subfolders to be created


def handle_response(func):
    def wrapper(*args, **kwargs):
        response_code = func(*args, **kwargs)

        if response_code == 500:
            message = f"Response code:{response_code} Internal Server Error."
        elif response_code == 405:
            message = f"Response code:{response_code} Request failed! Method Not Allowed"
        elif response_code == 422:
            message = f"Response code:{response_code} Unprocessable Entity"
        elif response_code == 401:
            message = f"Response code:{response_code} Unauthorized"
        else:
            message = f"Request failed. Status code: {response_code}"

        if response_code != 200:
            raise Exception(message)

        return response_code

    return wrapper

#The `Mobsf` class provides an interface to interact with a MobSF server.
class Mobsf:
    
    #server: The URL of the MobSF server.
    #apikey: The API key for the MobSF server.
    def __init__(self, server, apikey):
        self.server = server
        self.apikey = apikey

    def __str__(self):
        return f"{self.server}"
    
    def __repr__(self):
        return f"{self.server}"
    
    @staticmethod
    def hash_it(file, algorithm):
        '''
        Returns hash of the file provided, that can be different than the one provided by MobSF.

        :param file: file to hash (type: str/pathlib obj) :param algorithm: algorithm to
        to use for hashing (valid algorithms: sha1 | sha256 | md5) (type: str)
        :return: file hash (type: str)
        '''
        if algorithm == "sha256":
            hasher = hashlib.sha256()
        elif algorithm == "sha1":
            hasher = hashlib.sha1()
        elif algorithm == "md5":
            hasher = hashlib.md5()
        else:
            raise Exception(
                "Incompatible hash algorithm used. Choose from: sha256 | sha1 | md5")
        with open(file, 'rb') as f:
            hasher.update(f.read())
            return hasher.hexdigest()

    def _send_request(self, endpoint, data=None, headers=None, stream=False, timeout=30, retries=2):
        """
        Sends a request to the MobSF server.
        It is called every time a request is made to the MobSF server.
        Could skip it but then I would have to add the headers and the API key every time I make a request.
        
        :param endpoint: The endpoint to send the request to.
        :param data: The data to send with the request.
        :param headers: The headers to send with the request.
        :param stream: Whether to stream the response or not.
        """

        if headers is None:
            headers = {}
        headers['Authorization'] = self.apikey
        url = f"{self.server}/api/v1/{endpoint}"
        for retry in range(retries + 1):
            try:
                response = requests.post(url, data=data, headers=headers, stream=stream, timeout=timeout)
                return response
            except requests.exceptions.RequestException as e:
                print(f"Request failed: {e}")
                if retry < retries:
                    print(f"Retrying... Attempt {retry + 1}")
                    time.sleep(2)  # Wait 2 seconds before retrying
        return None  # Return None if all retries fail


    def upload_file(self, file_path):
        """
        Uploads a file to the MobSF server using MultipartEncoder with code 
        application/octet-stream that is used for binary file. 
        (Could also use application/vnd.android.package-archive' specificly for apk.)

        :param file_path: The path to the file to upload.
        :return: The response text from the server.
        """

        multipart_data = MultipartEncoder(
            fields={'file': (os.path.basename(file_path), open(file_path, 'rb'), 'application/octet-stream')})
        # 'application/octet-stream' for binary file  
        #'application/vnd.android.package-archive' for  apk
        headers = {'Content-Type': multipart_data.content_type}
        resp = self._send_request('upload', data=multipart_data, headers=headers)
        current_time = datetime.datetime.now().strftime("%H:%M:%S")
        if resp.status_code == 200:
            print(f"{current_time} - Uploaded file {os.path.basename(file_path)}")
            return resp.text
        else:
            print(f"Request failed with response code {resp.status_code}")


    @handle_response
    def scan(self, file_hash):
        """
        Scans the file. Timeout is set to 350 seconds and retries to 3,
        because some files bug and scan is stucked. So by retrying we can
        avoid this problem. 
        
        :param file_hash: The hash of the file to scan.
        :return: The response code from the server.
        """
    
        data = {"hash": file_hash}
        resp = self._send_request('scan', data=data, timeout=350, retries=3)
        time.sleep(2)
        current_time = datetime.datetime.now().strftime("%H:%M:%S")
        if resp.status_code == 200:
            print(f"{current_time} - Scan completed for the file with hash: {file_hash}")
        return resp.status_code


    @handle_response
    def scorecard(self, file_hash, my_hash):
        """
        Generate JSON Scorecard and save to a file in a subfolder
        
        :param file_hash: The hash of the file to generate scorecard.
        :return: The response code from the server.
        """

        print(f"Generating Scorecard for file with hash {my_hash}")
        data = {"hash": file_hash}
        resp = self._send_request('scorecard', data=data)
        if resp.status_code == 200:

            #initialize 'directory' variable with the directory where you want the subfolder "scorecards" to be created
            directory = ""
            sub_folder = os.path.join(directory, "Malware Analysis", "scorecards")
            os.makedirs(sub_folder, exist_ok=True)
            file_name = f"{sub_folder}/scorecard_{my_hash}.json"
            with open(file_name, 'w') as json_file:
                json.dump(resp.json(), json_file, indent=4)
            current_time = datetime.datetime.now().strftime("%H:%M:%S")
            print(f"{current_time} - JSON Scorecard saved as scorecard_{my_hash}")
        return resp.status_code

    @handle_response
    def pdf(self, file_hash, my_hash):
        """
        Generate PDF Report and save it to a file in a subfolder
        
        :param file_hash: The hash of the file to generate PDF report.
        :return: The response code from the server.
        """

        print(f"Generating PDF report for file with hash {my_hash}")
        data = {"hash": file_hash}
        resp = self._send_request('download_pdf', data=data, stream=True)
        if resp.status_code == 200:

            #initialize 'directory' variable with the directory where you want the subfolder "PDF Reports" to be created
            directory = ""
            sub_folder = os.path.join(directory, "Malware Analysis", "PDF Reports")
            os.makedirs(sub_folder, exist_ok=True)
            file_name = f"{sub_folder}/pdf_{my_hash}.pdf"
            with open(file_name, 'wb') as flip:
                for chunk in resp.iter_content(chunk_size=1024):
                    if chunk:
                        flip.write(chunk)
            current_time = datetime.datetime.now().strftime("%H:%M:%S")
            print(f"{current_time} - PDF report saved as report_{my_hash}.pdf")
        return resp.status_code


    @handle_response
    def generate_static_json_report(self, file_hash, my_hash):
        """
        Generate JSON Report and save to a file in a subfolder
        :param file_hash: The hash of the file to generate JSON report.
        :return: The response code from the server.
        """

        #initialize directory with the directory where you want the subfolder "scorecards" to be created

        current_time = datetime.datetime.now().strftime("%H:%M:%S")
        print(f"{current_time} - Generating JSON static report for file with hash {my_hash}")
        data = {"hash": file_hash}
        resp = self._send_request('report_json', data=data)
        if resp.status_code == 200:
        #initialize 'directory' variable with the directory where you want the subfolder "mobsf_static_reports" to be created

            json_report = resp.json()
            directory = "C:/Users/papag/OneDrive/Υπολογιστής"
            sub_folder = os.path.join(directory, "Malware Analysis", "mobsf_static_reports")
            os.makedirs(sub_folder, exist_ok=True)
            file_name = f"{sub_folder}/static_report_{my_hash}.json"
            with open(file_name, 'w') as json_file:
                json.dump(json_report, json_file, indent=4)
            current_time = datetime.datetime.now().strftime("%H:%M:%S")
            print(f"{current_time} - JSON static report saved as static_report_{my_hash}")
        return resp.status_code


    @handle_response
    def delete_scan(self, file_hash):
        """
        Delete Scan Result
        :param file_hash: The hash of the file to delete scan result.
        :return: The response code from the server.
        """
        print("Deleting Scan for hash:", file_hash)
        data = {"hash": file_hash}
        resp = self._send_request('delete_scan', data=data)
        return resp.status_code
     
        
    @handle_response
    def start_dynamic_analysis(self, file_hash):
        """
        Start Dynamic Analysis
        :param file_hash: The hash of the file to start dynamic analysis.
        :return: The response code from the server.
        """
        
        print("Starting dynamic analysis for hash:", file_hash)
        data = {"hash": file_hash}
        resp = self._send_request('dynamic/start_analysis', data=data)
        return resp.status_code
    

    @handle_response
    def start_frida_instrumentation(self, file_hash):
        """
        Start instrumentation using Frida
        :param file_hash: The hash of the file to start instrumentation.
        :return: The response code from the server.
        """

        current_time = datetime.datetime.now().strftime("%H:%M:%S")
        print(f"{current_time} - Starting instrumentation for hash:", file_hash)
        data = {
            "hash": file_hash,
            "default_hooks": "api_monitor,ssl_pinning_bypass,root_bypass,debugger_check_bypass",
            "auxiliary_hooks": "enum_class,string_catch,string_compare",
            "frida_code": ""
        }
        resp = self._send_request('frida/instrument', data=data)
        return resp.status_code

    @handle_response
    def start_exported_activities(self, file_hash):
        """
        Start apk's Exported Activities
        :param file_hash: The hash of the file to start exported activities.
        :return: The response code from the server.
        """

        print("Starting Exported Activities for hash:", file_hash)
        data = {
            "hash": file_hash,
            "test": "exported"
        }
        resp = self._send_request('android/activity', data=data)
        return resp.status_code

    @handle_response
    def start_activities(self, file_hash):
        """
        Starts apk's Activities(exported and unexported)
        :param file_hash: The hash of the file to start activities.
        :return: The response code from the server.
        """

        current_time = datetime.datetime.now().strftime("%H:%M:%S")
        print(f"{current_time} - Starting Activities for hash:", file_hash)
        data = {
            "hash": file_hash,
            "test": "com.package.android.MainActivity"
        }
        resp = self._send_request('android/activity', data=data)
        return resp.status_code

    
    @handle_response
    def generate_dynamic_json_report(self, file_hash, my_hash):
        """
        Generates Dynamic Analysis JSON report and save to a file in a sub_folder
        :param file_hash: The hash of the file to generate dynamic JSON report.
        :return: The response code from the server.
        """
    
        print("Generating Dynamic Analysis JSON report for hash:", my_hash)
        data = {"hash": file_hash}
        resp = self._send_request('dynamic/report_json', data=data)
        if resp.status_code == 200:
            json_report = resp.json()

            #initialize 'directory' variable with the directory where you want the subfolder "mobsf_dynamic_reports" to be created
            directory = "C:/Users/papag/OneDrive/Υπολογιστής"
            sub_folder = os.path.join(directory, "Malware Analysis", "mobsf_dynamic_reports")
            os.makedirs(sub_folder, exist_ok=True)
            file_name = f"{sub_folder}/dynamic_report_{my_hash}.json"
            with open(file_name, 'w') as json_file:
                json.dump(json_report, json_file, indent=4)
            current_time = datetime.datetime.now().strftime("%H:%M:%S")
            print(f"{current_time} - JSON dynamic_report saved as dynamic_report_{my_hash}")
        return resp.status_code

    @handle_response
    def stop_dynamic_analysis(self, file_hash):
        """
        Stops Dynamic Analysis
        :param file_hash: The hash of the file to stop dynamic analysis.
        :return: The response code from the server.
        """

        current_time = datetime.datetime.now().strftime("%H:%M:%S")
        print(f"{current_time} - Stopping dynamic analysis for hash:", file_hash)
        data = {"hash": file_hash}
        resp = self._send_request('dynamic/stop_analysis', data=data)
        return resp.status_code

    

